                        ; Tom PitIL_tman's 6800 tiny BASIC
                        ; reverse analyzed from (buggy) hexdump (TB68R1.tiff and TB68R2.tiff) at 
                        ; http://www.ittybittycomputers.com/IttyBitty/TinyBasic/index.htm
                        ; by Holger Veit
                        ; 
                        ; Note this might look like valid assembler, but possibly isn't
                        ; for reference only
                        ;
                        ; DGG - Noted my changes with my initials
                        ; Assemble using a68
                        ;	a68 TB_6800.ASM -l TB_6800.LST -s TB_6800.s
                        ; Load via DGG_MIKBUG with
                        ; &
                        ; Then copy/paste into terminal window
                        
   0000                                 org    0
   0000                                 rmb    32
   0020                 start_prgm:     rmb    2            ; start of BASIC text (0x900)
   0022                 end_ram:        rmb    2            ; end of available RAM
   0024                 end_prgm:       rmb    2            ; end of BASIC text
   0026                 top_of_stack:   rmb    2            ; top of return stack pointer location
   0028                 basic_lineno:   rmb    2            ; save for current line number to be executed
   002a                 il_pc:          rmb    2            ; program counter for IL code
   002c                 basic_ptr:      rmb    2            ; pointer to currently executed BASIC byte
   002e                 basicptr_save:  rmb    2            ; temporary save for basic_ptr
   0030                 expr_stack:     rmb    80           ; lowest byte of expr_stack (0x30)
   0080                 rnd_seed:       rmb    2            ; used as seed value for RND function
                                                            ; note this is actually top of predecrementing expr_stack
   0082                 var_tbl:        rmb    52           ; variables (A-Z), 26 words
   00b6                 LS_end:         rmb    2            ; used to store addr of end of LS listing,
                                                            ; start of list is in basic_ptr
   00b8                 BP_save:        rmb    2            ; another temporary save for basic_ptr
   00ba                 X_save:         rmb    2            ; temporary save for X
   00bc                 IL_temp:        rmb    2            ; temporary for various IL operations
                                                            ; used for branch to IL handler routine for opcode
   00be                 lead_zero:      rmb    1            ; flag for number output and negative sign in DV
   00bf                 column_cnt:     rmb    1            ; counter for output columns (required for TAB in PRINT)
                                                            ; if bit 7 is set, suppress output (XOFF)
   00c0                 run_mode:       rmb    1            ; run mode
                                                            ; = 0 direct mode
                                                            ; <> 0 running program
   00c1                 expr_stack_low: rmb    1            ; low addr byte of expr_stack (should be 0x30)
   00c2                 expr_stack_x:   rmb    1            ; high byte of expr_stack_top (==0x00, used with X register)
   00c3                 expr_stack_top: rmb    1            ; low byte of expr_stack_top (used in 8 bit comparisons)
   00c4                 il_pc_save:     rmb    2            ; save of IL program counter
   00c6                                 rmb    58           ; unused area in zero page (starting with 0xc6)
                        
                        ; cold start vector
                        ; DGG - Hard coded to $0100
   0100                                 org    $0100
                        
   0100   bd 02 00      CV:             jsr    COLD_S       ; Do cold start initialization
                        
                        ; warm start vector
   0103   7e 02 25      WV:             jmp    WARM_S       ; do warm start
                        
                        ; vector: get a character from input device into A
                        ; unimplemented - jump to system specific input routine
                        ; DGG - Calls MIKBUG input (IN1 at $f1f5)
   0106   7e f1 f5      IN_V:           jmp    $f1f5
                        
                        ; print a character in A to output device
                        ; unimplemented - jump to system specific output routine
                        ; DGG - Calls MIKBUG output (OUTEEE at $f20a)
   0109   7e f2 0a      OUT_V:          jmp    $f20a
                        
                        ; test for break from input device, set C=1 if break
                        ; unimplemented - jump to break routine
                        ; note: at the end of the program, there are two
                        ; sample implementations for MIKBUG and MINIBUG
   010c   01            BV:             nop
   010d   0c                            clc
   010e   39                            rts
                        
                        ; some standard constants
   010f   5f            BSC:            fcb    $5F          ; backspace code (should be 0x7f, but actually is '_')
   0110   18            LSC:            fcb    $18          ; line cancel code (CTRL-X)
   0111   83            PCC:            fcb    $83          ; CRLF padding characters
                                                            ; low 7 bits are number of NUL/0xFF
                        									; bit7=1: send 0xFF, =0, send NUL
   0112   80            TMC:            fcb    $80          ; 
   0113   20            SSS:            fcb    $20          ; reserved bytes at end_prgm (to prevent return stack
                                                            ; underflow (spare area)
                        
                        ;******************************************************************************
                        ; utility routines for BASIC (not called in interpreter code)
                        ;******************************************************************************
                        
                        ;------------------------------------------------------------------------------
                        ; get the byte pointed to by X into B:A
                        ;------------------------------------------------------------------------------
   0114   a6 00         peek:           ldaa   0,x
   0116   5f                            clrb
   0117   39                            rts
                        
                        ;------------------------------------------------------------------------------
                        ; put the byte in A into cell pointed to by X
                        ;------------------------------------------------------------------------------
   0118   a7 00         poke:           staa   0,x
   011a   39                            rts
                        
                        ;******************************************************************************
                        ; Interpreter jump table
                        ;******************************************************************************
   011b                 il_jumptable:
   011b   02 98                        fdb     IL_BBR       ; 0x40-0x5f: backward branch
   011d   02 9b                        fdb     IL_FBR       ; 0x60-0x7f: forward_branch
   011f   02 ee                        fdb     IL_BC        ; 0x80-0x9f: string match branch
   0121   03 12                        fdb     IL_BV        ; 0xa0-0xbf: branch if not variable
   0123   03 3b                        fdb     IL_BN        ; 0xc0-0xdf: branch if not number
   0125   03 0b                        fdb     IL_BE        ; 0xe0-0xff: branch if not eoln
   0127   01 fc                        fdb     IL_NO        ; 0x08:      no operation
   0129   01 d7                        fdb     IL_LB        ; 0x09:      push literal byte to TOS
   012b   01 db                        fdb     IL_LN        ; 0x0a:      push literal word to TOS
   012d   01 89                        fdb     IL_DS        ; 0x0b:      duplicate stack top
   012f   01 a6                        fdb     IL_SP        ; 0x0c:      pop TOS into A:B
   0131   01 a9                        fdb     expr_pop_byte ; 0x0d:     undocumented: pop byte into
   0133   01 77                        fdb     sub_177      ; 0x0e:      undocumented: push TOS on return stack
   0135   01 80                        fdb     sub_180      ; 0x0f:      undocumented: pop return stack into TOS
   0137   04 ab                        fdb     IL_SB        ; 0x10:      save BASIC pointer
   0139   04 b0                        fdb     IL_RB        ; 0x11:      restore BASIC pointer
   013b   04 00                        fdb     IL_FV        ; 0x12:      fetch variable
   013d   04 10                        fdb     IL_SV        ; 0x13:      store variable
   013f   04 ce                        fdb     IL_GS        ; 0x14:      save GOSUB line
   0141   04 99                        fdb     IL_RS        ; 0x15:      restore saved line
   0143   04 8e                        fdb     IL_GO        ; 0x16:      goto
   0145   03 c2                        fdb     IL_NE        ; 0x17:      negate
   0147   03 cf                        fdb     IL_AD        ; 0x18:      add
   0149   03 cd                        fdb     IL_SU        ; 0x19:      subtract
   014b   03 e5                        fdb     IL_MP        ; 0x1a:      multiply
   014d   03 6b                        fdb     IL_DV        ; 0x1b:      divide
   014f   04 23                        fdb     IL_CP        ; 0x1c:      compare
   0151   04 49                        fdb     IL_NX        ; 0x1d:      next BASIC statement
   0153   01 fc                        fdb     IL_NO        ; 0x1e:      reserved
   0155   05 d7                        fdb     IL_LS        ; 0x1f:      list program
   0157   05 45                        fdb     IL_PN        ; 0x20:      print number
   0159   05 ba                        fdb     IL_PQ        ; 0x21:      print BASIC string
   015b   05 c2                        fdb     IL_PT        ; 0x22:      print tab
   015d   06 28                        fdb     IL_NL        ; 0x23:      new line
   015f   05 ad                        fdb     IL_PC        ; 0x24:      print literal string
   0161   05 cb                        fdb     pt_print_spc ; 0x25:      undocumented op for SPC(x) function
   0163   01 fc                        fdb     IL_NO        ; 0x26:      reserved
   0165   06 5a                        fdb     IL_GL        ; 0x27:      get input line
   0167   01 fc                        fdb     IL_NO        ; 0x28:      reserved
   0169   01 fc                        fdb     IL_NO        ; 0x29:      reserved
   016b   06 b2                        fdb     IL_IL        ; 0x2A:      Insert BASIC line
   016d   02 12                        fdb     IL_MT        ; 0x2B:      mark BASIC program space empty
   016f   04 7e                        fdb     IL_XQ        ; 0x2C:      execute
   0171   02 25                        fdb     WARM_S       ; 0x2D:      warm start
   0173   01 b9                        fdb     IL_US        ; 0x2E:      machine language subroutine call
   0175   04 a6                        fdb     IL_RT        ; 0x2F:      IL subroutine return
                        
                        ;------------------------------------------------------------------------------
                        ; undocumented IL instruction (unused)
                        ; will take a value from expression stack
                        ; and put onto processor stack
                        ;------------------------------------------------------------------------------
   0177   8d 2d         sub_177:       bsr     IL_SP        ; pop word into A:B
   0179   97 bc                        staa    IL_temp      ; save into IL_temp
   017b   d7 bd                        stab    IL_temp+1
   017d   7e 04 d7                     jmp     push_payload ; push value on return stack
                        
                        ;------------------------------------------------------------------------------
                        ; undocumented IL instruction
                        ; will extract stored value on processor stack
                        ; and push back on expr_stack
                        ;------------------------------------------------------------------------------
   0180   bd 04 fc      sub_180:       jsr     get_payload  ; extract stored value on return stack
   0183   96 bc                        ldaa    IL_temp      ; get this value
   0185   d6 bd                        ldab    IL_temp+1
   0187   20 04                        bra     expr_push_word ; push on expr_stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: duplicate top    of expr_stack
                        ;------------------------------------------------------------------------------
   0189   8d 1b         IL_DS:         bsr    IL_SP         ; pop top of expr_stack into A:B
   018b   8d 00                        bsr    *+2           ; push A:B twice on expr_stack
                                                            ; (fall through to expr_push_word routine)
                        
                        ;------------------------------------------------------------------------------
                        ; push A:B on expr_stack
                        ;------------------------------------------------------------------------------
   018d   de c2         expr_push_word: ldx    expr_stack_x ; get expr_stack top
   018f   09                           dex                  ; make space for another byte
   0190   e7 00                        stab    0,x          ; store byte (low)
   0192   20 02                        bra     expr_push_a  ; push A byte
                        
                        ;------------------------------------------------------------------------------
                        ; push A on expr_stack
                        ;------------------------------------------------------------------------------
   0194   de c2         expr_push_byte: ldx    expr_stack_x ; get expr_stack top
                        
   0196   09            expr_push_a:   dex                  ; make space for another byte
   0197   a7 00                        staa    0,x          ; save A as new TOS (top of stack value)
   0199   df c2                        stx     expr_stack_x ; set new stack top
   019b   36                           psha                 ; save A
   019c   96 c1                        ldaa    expr_stack_low ; get stack bottom
   019e   91 c3                        cmpa    expr_stack_top ; stack overflow?
   01a0   32                           pula                 ; restore A
   01a1   25 59                        bcs     IL_NO        ; no, exit
                        
   01a3   7e 02 5c      j_error:       jmp     error        ; error: stack overflow
                        
                        ;------------------------------------------------------------------------------
                        ; pop the TOS word off stack, result in A:B
                        ;------------------------------------------------------------------------------
   01a6   8d 01         IL_SP:         bsr     expr_pop_byte ; pop a byte into B
   01a8   17                           tba                  ; put into A (high byte)
                                                            ; fall thru to expr_pop_byte to get more
                        
                        ;------------------------------------------------------------------------------
                        ; pop the TOS byte off stack into B
                        ;------------------------------------------------------------------------------
   01a9   c6 01         expr_pop_byte: ldab    #1           ; verify stack is not empty: has 1 byte
                        
   01ab   db c3         pop_byte:      addb    expr_stack_top ; next position on stack
   01ad   c1 80                        cmpb    #$80         ; is it > 0x80?
   01af   22 f2                        bhi     j_error      ; yes, stack underflow error
   01b1   de c2                        ldx     expr_stack_x ; get address of stack top
   01b3   7c 00 c3                     inc     expr_stack_top  ; pop stack
   01b6   e6 00                        ldab    0,x          ; get TOS byte in B
   01b8   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction US: machine language subroutine call
                        ;------------------------------------------------------------------------------
   01b9   8d 05         IL_US:         bsr     us_do        ; call machine language routine
   01bb   8d d7                        bsr     expr_push_byte ; return here when ML routine does RTS
                                                            ; push A:B on stack
   01bd   17                           tba
   01be   20 d4                        bra     expr_push_byte
                        
   01c0   86 06         us_do:         ldaa    #6           ; verify that stack has at least 6 bytes
   01c2   16                           tab
   01c3   9b c3                        adda    expr_stack_top
   01c5   81 80                        cmpa    #rnd_seed    ; at end of expr_stack?
   01c7   22 da                        bhi     j_error      ; yes, error
   01c9   de c2                        ldx     expr_stack_x ; load argument list
   01cb   97 c3                        staa    expr_stack_top ; drop 6 bytes from stack
                        
   01cd   a6 05         us_copyargs:   ldaa    5,x          ; push 5 bytes to return stack
   01cf   36                           psha
   01d0   09                           dex
   01d1   5a                           decb
   01d2   26 f9                        bne     us_copyargs  ; loop until done
   01d4   07                           tpa                  ; push status
   01d5   36                           psha
                                       ; Stack frame is
                                       ; return address IL_US+2 (caller of bsr us_do)
                                       ; B
                                       ; A
                                       ; X
                                       ; X
                                       ; address
                                       ; address
                                       ; PSW
   01d6   3b                           rti                  ; use RTI to branch to routine
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction push byte
                        ;------------------------------------------------------------------------------
   01d7   8d 1c         IL_LB:         bsr     fetch_il_op  ; get next byte from sequence
   01d9   20 b9                        bra     expr_push_byte  ; push single byte
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction push word
                        ;------------------------------------------------------------------------------
   01db   8d 18         IL_LN:         bsr     fetch_il_op  ; get next two bytes into A:B
   01dd   36                           psha
   01de   8d 15                        bsr     fetch_il_op
   01e0   16                           tab
   01e1   32                           pula
   01e2   20 a9                        bra     expr_push_word ; push on stack
                        
                        ;------------------------------------------------------------------------------
                        ; part of IL linterpreter loop, handle SX instruction
                        ;------------------------------------------------------------------------------
   01e4   9b c3         handle_il_SX:  adda    expr_stack_top ; opcode is 0..7, add to current stack ptr
   01e6   97 bd                        staa    IL_temp+1      ; make word pointer 0x00SP+opcode
   01e8   7f 00 bc                     clr     IL_temp
   01eb   8d bc                        bsr     expr_pop_byte  ; drop to byte into B
   01ed   de bc                        ldx     IL_temp        ; get index
   01ef   a6 00                        ldaa    0,x            ; get old byte
   01f1   e7 00                        stab    0,x            ; store byte from TOS there
   01f3   20 9f                        bra     expr_push_byte ; store old byte on TOS
                        
                        ;------------------------------------------------------------------------------
                        ; get the next IL opcode and increment the IL PC
                        ;------------------------------------------------------------------------------
   01f5   de 2a         fetch_il_op:   ldx     il_pc        ; get IL PC
   01f7   a6 00                        ldaa    0,x          ; read next opcode
   01f9   08                           inx                  ; advance to next byte
   01fa   df 2a                        stx     il_pc        ; save IL PC
                        
   01fc   4d            IL_NO:         tsta                 ; set flags
   01fd   39                           rts
                        
                        ;------------------------------------------------------------------------------
   01fe   07 a2         IL_baseaddr:   fdb start_of_il      ; only used address where IL code starts
                        
                        ;------------------------------------------------------------------------------
                        ; Cold start entry point
                        ;------------------------------------------------------------------------------
   0200   ce 09 00      COLD_S:        ldx     #$0900		; DGG - initialize start of BASIC
   0203   df 20                        stx     start_prgm
                        
   0205   08            find_end_ram:  inx                  ; point to next address
   0206   63 01                        com     1,x          ; complement following byte
   0208   a6 01                        ldaa    1,x          ; load byte
   020a   63 01                        com     1,x          ; complement byte
   020c   a1 01                        cmpa    1,x          ; compare with value, should be different, if it is RAM
   020e   26 f5                        bne     find_end_ram ; if different, advance, until no more RAM cells found
   0210   df 22                        stx     end_ram      ; use topmost RAM cell
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction MT: clear program
                        ;------------------------------------------------------------------------------
   0212   96 20         IL_MT:         ldaa    start_prgm   ; load start area
   0214   d6 21                        ldab    start_prgm+1
   0216   fb 01 13                     addb    SSS          ; add spare area after end of program
   0219   89 00                        adca    #0
   021b   97 24                        staa    end_prgm     ; save as end of program
   021d   d7 25                        stab    end_prgm+1
   021f   de 20                        ldx     start_prgm   ; get addr of start of program
   0221   6f 00                        clr     0,x          ; clear line number (means end)
   0223   6f 01                        clr     1,x
                        
                        ;------------------------------------------------------------------------------
                        ; warm start entry point
                        ;------------------------------------------------------------------------------
   0225   9e 22         WARM_S:        lds     end_ram      ; set return stack to end of RAM
                        
                                       ; enters here to start IL loop;
                        			   ; return here after error stop
   0227   bd 06 2c      restart_il:    jsr     crlf         ; emit a CRLF
                        
   022a   fe 01 fe      restart_il_nocr: ldx   IL_baseaddr  ; load pointer to IL
   022d   df 2a                        stx     il_pc        ; store as current IL PC
   022f   ce 00 80                     ldx     #rnd_seed    ; set expr_stack top to 0x0080
   0232   df c2                        stx     expr_stack_x
   0234   ce 00 30                     ldx     #$30         ; set run_mode = 0 (no program)
                                                            ; set expr_stack_low = 0x30
   0237   df c0                        stx     run_mode
                        
   0239   9f 26         il_rs_return:  sts     top_of_stack ; save current stack position
                        
   023b   8d b8         il_mainloop:   bsr     fetch_il_op  ; fetch next IL opcode
   023d   8d 07                        bsr     exec_il_opcode ; execute current IL instruction
   023f   20 fa                        bra     il_mainloop  ; next instruction
                        
                                       ; trick programming here:
                                       ; this location is entered in IL_RS
                                       ; by incrementing the return address of exec_il_opcode
                                       ; so that it skips over the 'BRA il_mainloop' above
   0241   8c 20 04      il_rs_target:  cpx     #$2004       ; this might mask a BRA *+4, which however would
                                                            ; then point into exec_il_opcode+2, which is a TBA
                                                            ; which could then be used for a synthetic 
                        									; exec_il_opcode...
                                                            ; frankly: this is possibly either a remainder
                                                            ; from old code or a hidden serial number
                        									; the 6502 code has a similar anachronism in this
                        									; place, so it might be a serial number.
   0244   20 f3                        bra     il_rs_return ; enforce storing the stack pointer and do il_mainloop
                        
                        ;------------------------------------------------------------------------------
                        ; with IL opcode in A, decode opcode and
                        ; branch to appropriate routine
                        ;------------------------------------------------------------------------------
   0246   ce 01 17      exec_il_opcode: ldx    #il_jumptable-4 ; preload address of opcode table - 4
   0249   df bc                        stx     IL_temp
   024b   81 30                        cmpa    #$30         ; is opcode below 0x30?
   024d   24 56                        bcc     handle_30_ff ; no, skip to handler for higher opcodes
   024f   81 08                        cmpa    #8           ; is it below 8?
   0251   25 91                        bcs     handle_il_SX ; yes, skip to handler for SX instructions
   0253   48                           asla                 ; make word index
   0254   97 bd                        staa    IL_temp+1    ; store as offset
   0256   de bc                        ldx     IL_temp
   0258   ee 17                        ldx     $17,x        ; load handler address via offset
   025a   6e 00                        jmp     0,x          ; jump to handler
                        
                        ;------------------------------------------------------------------------------
                        ; common error routine
                        ;------------------------------------------------------------------------------
   025c   bd 06 2c      error:         jsr     crlf         ; emit CRLF
   025f   86 21                        ldaa    #'!'
   0261   97 c1                        staa    expr_stack_low ; lower stack bottom a bit to avoid another stack fault
                                                            ; SNAFU already; may overwrite some variables
   0263   bd 01 09                     jsr     OUT_V        ; emit exclamation mark
   0266   86 80                        ldaa    #rnd_seed    ; reinitialize stack top
   0268   97 c3                        staa    expr_stack_top
   026a   d6 2b                        ldab    il_pc+1      ; load IL PC into A:B
   026c   96 2a                        ldaa    il_pc
   026e   f0 01 ff                     subb    IL_baseaddr+1 ; subtract origin of interpreter
   0271   b2 01 fe                     sbca    IL_baseaddr
   0274   bd 05 42                     jsr     emit_number  ; print instruction of IL
   0277   96 c0                        ldaa    run_mode     ; is not in program?
   0279   27 0f                        beq     error_no_lineno ; no, suppress output of line number
   027b   ce 02 93                     ldx     #err_at      ; load error string
   027e   df 2a                        stx     il_pc
   0280   bd 05 ad                     jsr     IL_PC        ; print string at il_prgm_cnt, i.e. "AT "
   0283   96 28                        ldaa    basic_lineno ; get line number
   0285   d6 29                        ldab    basic_lineno+1
   0287   bd 05 42                     jsr     emit_number  ; print it
                        
   028a   86 07         error_no_lineno: ldaa  #7           ; emit BEL (0x07) character
   028c   bd 01 09                     jsr     OUT_V
   028f   9e 26                        lds     top_of_stack ; restore return stack
   0291   20 94                        bra     restart_il   ; restart interpreter after error
                        
   0293   20 41 54 20   err_at:        fcb     ' ','A','T',' ',$80 ; string " AT " + terminator
   0297   80            
                        
                        ;------------------------------------------------------------------------------
                        ; long branch instruction
                        ;------------------------------------------------------------------------------
   0298   7a 00 bc      IL_BBR:        dec     IL_temp      ; adjust position for negative jump (effectively 2's complement)
                        
   029b   7d 00 bc      IL_FBR:        tst     IL_temp      ; test new position high byte
   029e   27 bc                        beq     error        ; was displacement 0?
                                                            ; yes, this is an error condition
                        
   02a0   de bc         il_goto:       ldx     IL_temp      ; get new IL target address
   02a2   df 2a                        stx     il_pc        ; do the jump
   02a4   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; part of interpreter loop: handle opcode 0x30-3f
                        ;------------------------------------------------------------------------------
   02a5   81 40         handle_30_ff:  cmpa    #$40         ; above or equal 0x40?
   02a7   24 23                        bcc     handle_40_ff ; yes, handle elsewhere
                        
                                       ; handle the J/JS instructions
   02a9   36                           psha                 ; save opcode
   02aa   bd 01 f5                     jsr     fetch_il_op  ; get next byte of instruction (low address)
   02ad   bb 01 ff                     adda    IL_baseaddr+1 ; add to IL interpreter base
   02b0   97 bd                        staa    IL_temp+1
   02b2   32                           pula                 ; restore opcode
   02b3   16                           tab                  ; save into B for later
   02b4   84 07                        anda    #7           ; mask out addressbits
   02b6   b9 01 fe                     adca    IL_baseaddr  ; add to base address
   02b9   97 bc                        staa    IL_temp      ; save in temporary
   02bb   c4 08                        andb    #8           ; mask J/JS bit
   02bd   26 e1                        bne     il_goto      ; if set, is GOTO
   02bf   de 2a                        ldx     il_pc        ; get current IL PC
   02c1   97 2a                        staa    il_pc        ; save new IL PC
   02c3   d6 bd                        ldab    IL_temp+1
   02c5   d7 2b                        stab    il_pc+1
   02c7   df bc                        stx     IL_temp      ; save old in temporary
   02c9   7e 04 d7                     jmp     push_payload ; put on return stack
                        
                        ;------------------------------------------------------------------------------
                        ; handle the opcodes >=0x40
                        ;------------------------------------------------------------------------------
   02cc   16            handle_40_ff:  tab                  ; save opcode for later
   02cd   44                           lsra                 ; get opcode high nibble
   02ce   44                           lsra
   02cf   44                           lsra
   02d0   44                           lsra
   02d1   84 0e                        anda    #$E          ; make 0x04,0x06,...0x0e
   02d3   97 bd                        staa    IL_temp+1    ; make index into opcode jump table
   02d5   de bc                        ldx     IL_temp
   02d7   ee 17                        ldx     $17,x        ; X points to handler routine
   02d9   4f                           clra                 ; preload A=0 for null displacement (error indicator)
   02da   c1 60                        cmpb    #$60         ; is it BBR?
   02dc   c4 1f                        andb    #$1F         ; mask out displacement bits
   02de   24 02                        bcc     not_bbr      ; was not backward branch
   02e0   ca e0                        orab    #$E0         ; make displacement negative
                        
   02e2   27 06         not_bbr:       beq     displ_error  ; displacement is zero? yes, skip
   02e4   db 2b                        addb    il_pc+1      ; add displayement to current IL_PC
   02e6   d7 bd                        stab    IL_temp+1
   02e8   99 2a                        adca    il_pc
                        
   02ea   97 bc         displ_error:   staa    IL_temp      ; store high byte of new address
                                                            ; if displayement=0, store high byte=0
                                                            ; -> invalid IL address, will lead to error
   02ec   6e 00                        jmp     0,x          ; jump to handler routine
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction string match branch
                        ; jump forward if string was not matched
                        ;------------------------------------------------------------------------------
   02ee   de 2c         IL_BC:         ldx     basic_ptr    ; save pointer to current BASIC character
   02f0   df b8                        stx     BP_save
                        
   02f2   8d 36         bc_loop:       bsr     get_nchar    ; skip spaces
   02f4   8d 2a                        bsr     fetch_basicchar ; consume char
   02f6   16                           tab                  ; save into B
   02f7   bd 01 f5                     jsr     fetch_il_op  ; get next char from IL stream
   02fa   2a 02                        bpl     bc_lastchar  ; if positive (not end of string), match further
   02fc   ca 80                        orab    #$80         ; no, make basic char also bit7 set
                        
   02fe   11            bc_lastchar:   cba                  ; compare bytes
   02ff   26 04                        bne     bc_nomatch   ; do not match, skip
   0301   4d                           tsta                 ; more chars to match?
   0302   2a ee                        bpl     bc_loop      ; yes, loop
   0304   39                           rts                  ; that string matched! continue
                        
   0305   de b8         bc_nomatch:    ldx     BP_save      ; restore BASIC pointer
   0307   df 2c                        stx     basic_ptr
                        
   0309   20 90         j_FBR:         bra     IL_FBR       ; and branch forward
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: jump if not end of line
                        ;------------------------------------------------------------------------------
   030b   8d 1d         IL_BE:         bsr     get_nchar    ; get current BASIC char
   030d   81 0d                        cmpa    #$D          ; is it a CR?
   030f   26 f8                        bne     j_FBR        ; no, jump forward
   0311   39                           rts                  ; continue
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: branch if not variable
                        ; if variable, push 2*ASCII to expr_stack
                        ; (0x41..0x5A => 0x82...0xB4
                        ;  == offset to var table into zero page)
                        ;------------------------------------------------------------------------------
   0312   8d 16         IL_BV:         bsr     get_nchar    ; get current BASIC char
   0314   81 5a                        cmpa    #'Z'         ; is it an alphanumeric?
   0316   2e f1                        bgt     j_FBR        ; no, jump forward
   0318   81 41                        cmpa    #'A'
   031a   2d ed                        blt     j_FBR
   031c   48                           asla                 ; yes, double the ASCII code
                        			                        ; (make it a word index into var table
   031d   bd 01 94                     jsr     expr_push_byte ; push it on the stack
                                                            ; ...and consume this character
                        									; (fall thru to fetch_basicchar)
                        
                        ;------------------------------------------------------------------------------
                        ; get next BASIC char from program or line
                        ; return in A, Z=1 if CR
                        ;------------------------------------------------------------------------------
   0320                 fetch_basicchar:
   0320   de 2c                        ldx     basic_ptr    ; get address of current BASIC byte
   0322   a6 00                        ldaa    0,x          ; get byte
   0324   08                           inx                  ; advance to next character
   0325   df 2c                        stx     basic_ptr    ; save it
   0327   81 0d                        cmpa    #$D          ; check if 0x0d (end of line)
   0329   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; get next BASIC char (without advance)
                        ; C=1 if digit
                        ;------------------------------------------------------------------------------
   032a   8d f4         get_nchar:     bsr     fetch_basicchar ; get next char
   032c   81 20                        cmpa    #' '         ; is it a space?
   032e   27 fa                        beq     get_nchar    ; yes, skip that
   0330   09                           dex                  ; is no space, point back to this char
   0331   df 2c                        stx     basic_ptr
   0333   81 30                        cmpa    #'0'         ; is it a digit?
   0335   0c                           clc
   0336   2d 02                        blt     locret_33A   ; no, return C=0
   0338   81 3a                        cmpa    #':'         ; return C=1 if number
                        
   033a   39            locret_33A:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: branch if not number
                        ; if digit, convert this and following digits to number
                        ; and push on expr_stack
                        ;------------------------------------------------------------------------------
   033b   8d ed         IL_BN:         bsr     get_nchar    ; get BASIC char
   033d   24 ca                        bcc     j_FBR        ; if not digit, do forward branch
   033f   ce 00 00                     ldx     #0           ; clear temporary for number
   0342   df bc                        stx     IL_temp
                        
   0344   8d da         loop_bn:       bsr     fetch_basicchar ; get and consume this char
   0346   36                           psha                 ; save it
   0347   96 bc                        ldaa    IL_temp      ; multiply TEMP by 10
   0349   d6 bd                        ldab    IL_temp+1
   034b   58                           aslb                 ; temp*2
   034c   49                           rola
   034d   58                           aslb                 ; (temp*2)*2 = temp*4
   034e   49                           rola
   034f   db bd                        addb    IL_temp+1    ; (temp*4)+temp = temp*5
   0351   99 bc                        adca    IL_temp
   0353   58                           aslb                 ; (temp*5)*2 = temp*10
   0354   49                           rola
   0355   d7 bd                        stab    IL_temp+1
   0357   33                           pulb                 ; restore digit
   0358   c4 0f                        andb    #$F          ; mask out low nibble (0...9)
   035a   db bd                        addb    IL_temp+1    ; add into temp
   035c   89 00                        adca    #0
   035e   97 bc                        staa    IL_temp
   0360   d7 bd                        stab    IL_temp+1
   0362   8d c6                        bsr     get_nchar    ; get next char
   0364   25 de                        bcs     loop_bn      ; loop as long as digit found
   0366   96 bc                        ldaa    IL_temp      ; push A:B on expr_stack (B is still low byte)
   0368   7e 01 8d                     jmp     expr_push_word
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: divide
                        ;------------------------------------------------------------------------------
   036b   8d 73         IL_DV:         bsr     expr_check_4bytes ; validate 2 args on stack; discard 1 byte
   036d   a6 02                        ldaa    2,x          ; high byte dividend
   036f   47                           asra                 ; put sign into carry
   0370   49                           rola
   0371   a2 02                        sbca    2,x          ; A=0xFF if sign=1, 0x00 if sign=0
   0373   97 bc                        staa    IL_temp      ; sign extend dividend into 32bit (IL_temp=high word)
   0375   97 bd                        staa    IL_temp+1
   0377   16                           tab                  ; if negative, subtract 1 from dividend
   0378   eb 03                        addb    3,x          ; 0x0000...0x7fff stays positive
                                                            ; 0x8000 becomes positive
                                                            ; 0x8001...0xffff stays negative
   037a   e7 03                        stab    3,x
   037c   16                           tab
   037d   e9 02                        adcb    2,x
   037f   e7 02                        stab    2,x
   0381   a8 00                        eora    0,x          ; compare with sign of divisor
   0383   97 be                        staa    lead_zero    ; store result sign (negative if different, positive if same)
   0385   2a 02                        bpl     loc_389      ; if different sign, complement divisor
                                                            ; i.e. NEG/NEG -> do nothing
                                                            ;      NEG/POS -> NEG/NEG + lead_zero <0
                                                            ;      POS/NEG -> POS/POS + lead_zero <0
                                                            ;      POS/POS -> do nothing
   0387   8d 3b                        bsr     negate       ; negate operand
                        
   0389   c6 11         loc_389:       ldab    #$11         ; loop counter (16+1 iterations)
   038b   a6 00                        ldaa    0,x          ; is divisor = 0?
   038d   aa 01                        oraa    1,x
   038f   26 03                        bne     dv_loop      ; no, do division
   0391   7e 02 5c                     jmp     error
                        
   0394   96 bd         dv_loop:       ldaa    IL_temp+1    ; subtract divisor from 32bit dividend
   0396   a0 01                        suba    1,x
   0398   36                           psha                 ; remember result
   0399   96 bc                        ldaa    IL_temp
   039b   a2 00                        sbca    0,x
   039d   36                           psha
   039e   98 bc                        eora    IL_temp
   03a0   2b 09                        bmi     dv_smaller   ; subtract result was <0 ?
   03a2   32                           pula                 ; no, can subtract, remember a 1 bit (sec)
   03a3   97 bc                        staa    IL_temp      ; and store new result
   03a5   32                           pula
   03a6   97 bd                        staa    IL_temp+1
   03a8   0d                           sec
   03a9   20 03                        bra     dv_shift
                        
   03ab   32            dv_smaller:    pula                 ; discard subtraction
   03ac   32                           pula
   03ad   0c                           clc                  ; remember 0 bit
                        
   03ae   69 03         dv_shift:      rol     3,x          ; shift 32bit dividend left
   03b0   69 02                        rol     2,x          ; shift in result bit into lowest bit of dividend
   03b2   79 00 bd                     rol     IL_temp+1
   03b5   79 00 bc                     rol     IL_temp
   03b8   5a                           decb                 ; decrement loop
   03b9   26 d9                        bne     dv_loop      ; subtract divisor from  32bit dividend
   03bb   8d 20                        bsr     j_expr_pop_byte ; drop a byte (other one was already removed above)
                                                            ; X points to result in (former) dividend at 2,X
   03bd   7d 00 be                     tst     lead_zero    ; operand signs were different?
   03c0   2a 0a                        bpl     locret_3CC   ; no, we are done
                        			                        ; else fall thru to negation (of result)
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: negate top of stack
                        ;------------------------------------------------------------------------------
   03c2   de c2         IL_NE:         ldx     expr_stack_x ; point to TOS
   03c4   60 01         negate:        neg     1,x          ; negate low byte
   03c6   26 02                        bne     ne_nocarry   ; not zero: no carry
   03c8   6a 00                        dec     0,x          ; propagate carry into high byte
                        
   03ca   63 00         ne_nocarry:    com     0,x          ; complement high byte
                        
   03cc   39            locret_3CC:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: subtract TOS from NOS -> NOS
                        ;------------------------------------------------------------------------------
   03cd   8d f3         IL_SU:         bsr     IL_NE        ; negate TOS. A-B is A+(-B)
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: add TOS and NOS -> NOS
                        ;------------------------------------------------------------------------------
   03cf   8d 0f         IL_AD:         bsr     expr_check_4bytes ; verify 4 bytes on stack
   03d1   e6 03                        ldab    3,x          ; add TOS and NOS into AB
   03d3   eb 01                        addb    1,x
   03d5   a6 02                        ldaa    2,x
   03d7   a9 00                        adca    0,x
                        
   03d9   a7 02         expr_save_pop: staa    2,x          ; store A:B in NOS and pop further byte
   03db   e7 03                        stab    3,x
                        
   03dd   7e 01 a9      j_expr_pop_byte: jmp   expr_pop_byte
                        
                        ;------------------------------------------------------------------------------
                        ; validate stack contains at least 4 bytes, pop 1 byte
                        ;------------------------------------------------------------------------------
   03e0   c6 04         expr_check_4bytes: ldab #4
                        
   03e2   7e 01 ab      expr_check_nbytes: jmp  pop_byte    ; pop a byte
                        
                        ;------------------------------------------------------------------------------
                        ; multiply TOS with NOS -> NOS
                        ; I think this this routine is broken for negative numbers
                        ;------------------------------------------------------------------------------
   03e5   8d f9         IL_MP:         bsr     expr_check_4bytes ; validate 2 args
   03e7   86 10                        ldaa    #$10         ; bit count (16 bits)
   03e9   97 bc                        staa    IL_temp
   03eb   4f                           clra                 ; clear bottom 16 bits of result
   03ec   5f                           clrb
                        
   03ed   58            mp_loop:       aslb                 ; shift 1 bit left
   03ee   49                           rola
   03ef   68 01                        asl     1,x          ; shift 1st operand
   03f1   69 00                        rol     0,x
   03f3   24 04                        bcc     mp_notadd    ; is top bit = 1?
   03f5   eb 03                        addb    3,x          ; yes, add 2nd operand into A:B
   03f7   a9 02                        adca    2,x
                        
   03f9   7a 00 bc      mp_notadd:     dec     IL_temp      ; decrement counter
   03fc   26 ef                        bne     mp_loop      ; loop 16 times
   03fe   20 d9                        bra     expr_save_pop ; save result
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: fetch variable
                        ;------------------------------------------------------------------------------
   0400   8d db         IL_FV:         bsr     j_expr_pop_byte ; get byte (variable address into zero page)
   0402   d7 bd                        stab    IL_temp+1    ; make pointer into var table
   0404   7f 00 bc                     clr     IL_temp
   0407   de bc                        ldx     IL_temp
   0409   a6 00                        ldaa    0,x          ; get word indexed by X into A:B
   040b   e6 01                        ldab    1,x
   040d   7e 01 8d                     jmp     expr_push_word ; push it onto expr_stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: save variable
                        ;------------------------------------------------------------------------------
   0410   c6 03         IL_SV:         ldab    #3
   0412   8d ce                        bsr     expr_check_nbytes ; validate stack contains var index byte
                                                            ; and data word. drop single byte
   0414   e6 01                        ldab    1,x          ; get low byte of data in B
   0416   6f 01                        clr     1,x          ; clear this to build word index to var
   0418   a6 00                        ldaa    0,x          ; get high byte of data in A
   041a   ee 01                        ldx     1,x          ; load index into variable table
   041c   a7 00                        staa    0,x          ; save A:B into variable
   041e   e7 01                        stab    1,x
                        
   0420   7e 01 a6      j_IL_SP:       jmp     IL_SP        ; pop word off stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction compare
                        ; stack: TOS, MASK, NOS
                        ; compare TOS with NOS
                        ; MASK is bit0 = less
                        ;      bit1 = equal
                        ;      bit2 = greater
                        ; if compare reslut AND    mask return <>0, next IL op is skipped
                        ;------------------------------------------------------------------------------
   0423   8d fb         IL_CP:         bsr     j_IL_SP      ; pop TOS into A:B
   0425   37                           pshb                 ; save low byte
   0426   c6 03                        ldab    #3
   0428   8d b8                        bsr     expr_check_nbytes ; verify still 3 bytes on stack,
                        			                        ; drop one byte
   042a   7c 00 c3                     inc     expr_stack_top ; drop more bytes
   042d   7c 00 c3                     inc     expr_stack_top
   0430   33                           pulb                 ; restore low byte of TOS
   0431   e0 02                        subb    2,x          ; compare with 1st arg
                                                            ; note this subtraction is inverted
                        									; thus BGT means BLT, and vice versa
   0433   a2 01                        sbca    1,x
   0435   2e 0b                        bgt     cp_is_lt     ; if less, skip
   0437   2d 05                        blt     cp_is_gt     ; if greater, skip
   0439   5d                           tstb                 ; is result 0?
   043a   27 04                        beq     cp_is_eq
   043c   20 04                        bra     cp_is_lt
                        
   043e   67 00         cp_is_gt:      asr     0,x          ; shift bit 2 into carry
                        
   0440   67 00         cp_is_eq:      asr     0,x          ; shift bit 1 into carry
                        
   0442   67 00         cp_is_lt:      asr     0,x          ; shift bit 0 into carray
   0444   24 1b                        bcc     locret_461   ; not matched: exit, continue new IL op
   0446   7e 01 f5                     jmp     fetch_il_op  ; skip one IL op before continuing
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: advance to next BASIC line
                        ;------------------------------------------------------------------------------
   0449   96 c0         IL_NX:         ldaa    run_mode     ; run mode = 0?
   044b   27 1d                        beq     loc_46A      ; yes, continue program
                        
   044d                 nx_loop:                ; ...
   044d   bd 03 20                     jsr     fetch_basicchar ; get char from program
   0450   26 fb                        bne     nx_loop      ; is not CR, loop
   0452   8d 1d                        bsr     save_lineno  ; store line number
   0454   27 11                        beq     j1_error     ; is 0000 (end of program) -> error
                        
                        ;------------------------------------------------------------------------------
                        ; enters here from a GOTO,
                        ; basic pointer points to new line
                        ;------------------------------------------------------------------------------
   0456   8d 32         go_found_line: bsr    do_runmode    ; set run mode = running
   0458   bd 01 0c                     jsr    BV            ; test for BREAK
   045b   25 05                        bcs    do_break      ; if C=1, do break
   045d   de c4                        ldx    il_pc_save    ; restore IL_PC which was saved in XQ or GO
   045f   df 2a                        stx    il_pc
                        
   0461   39            locret_461:    rts
                        
   0462   fe 01 fe      do_break:      ldx    IL_baseaddr   ; restart interpreter
   0465   df 2a                        stx    il_pc
                        
   0467   7e 02 5c      j1_error:      jmp    error         ; and emit break error
                        
                        ;------------------------------------------------------------------------------
                        ; fragment of code for IL_NX
                        ;------------------------------------------------------------------------------
   046a   9e 26         loc_46A:       lds     top_of_stack ; reload stack
   046c   97 bf                        staa    column_cnt   ; clear column count (A was 0)
   046e   7e 02 2a                     jmp     restart_il_nocr ; restart interpreter
                        
                        ;------------------------------------------------------------------------------
                        ; save current linenumber
                        ;------------------------------------------------------------------------------
   0471   bd 03 20      save_lineno:   jsr     fetch_basicchar ; get char from program code
   0474   97 28                        staa    basic_lineno    ; save as high lineno
   0476   bd 03 20                     jsr     fetch_basicchar ; get char from program code
   0479   97 29                        staa    basic_lineno+1  ; save as low lineno
   047b   de 28                        ldx     basic_lineno    ; load line number for later
   047d   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: execute program
                        ;------------------------------------------------------------------------------
   047e   de 20         IL_XQ:         ldx     start_prgm   ; set current start of program
   0480   df 2c                        stx     basic_ptr
   0482   8d ed                        bsr     save_lineno  ; save current line number
   0484   27 e1                        beq     j1_error     ; if zero, error
   0486   de 2a                        ldx     il_pc        ; save current IL_PC
   0488   df c4                        stx     il_pc_save
                        
   048a   07            do_runmode:    tpa                  ; will load non zero value (0xc0) into A - tricky!
   048b   97 c0                        staa    run_mode     ; set run_mode = "running"
   048d   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction GO
                        ;------------------------------------------------------------------------------
   048e   bd 05 1a      IL_GO:         jsr     find_line    ; find line which lineno is on stack
   0491   27 c3                        beq     go_found_line ; found? yes, skip
                        
   0493   de bc         go_error:      ldx     IL_temp      ; set requested lineno as current
   0495   df 28                        stx     basic_lineno
   0497   20 ce                        bra     j1_error     ; error - line not found
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: restore saved line
                        ;------------------------------------------------------------------------------
   0499   8d 61         IL_RS:         bsr     get_payload  ; get saved line 2 levels off stack
   049b   30                           tsx                  ; point to caller of exec_il_opcode
   049c   6c 01                        inc     1,x          ; hack: adjust return from exec_il_mainloop
                                                            ; that it points to il_rs_target just below
                                                            ; il_mainloop
   049e   6c 01                        inc     1,x
   04a0   bd 05 25                     jsr     find_line1   ; find the basic line
   04a3   26 ee                        bne     go_error     ; line not found? -> error
   04a5   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction return from IL call
                        ;------------------------------------------------------------------------------
   04a6   8d 54         IL_RT:         bsr     get_payload  ; get saved IL PC address
   04a8   df 2a                        stx     il_pc        ; restore it to IL_PC
   04aa   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction save BASIC pointer
                        ;------------------------------------------------------------------------------
   04ab   ce 00 2c      IL_SB:         ldx     #basic_ptr   ; get address of basic pointer
   04ae   20 03                        bra     loc_4B3      ; continue in IL_RB common code
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: restore BASIC pointer
                        ;------------------------------------------------------------------------------
   04b0   ce 00 2e      IL_RB:         ldx     #basicptr_save
                        
   04b3   a6 01         loc_4B3:       ldaa    1,x          ; is it into the input line area?
   04b5   81 80                        cmpa    #$80
   04b7   24 08                        bcc     swap_bp      
   04b9   a6 00                        ldaa    0,x
   04bb   26 04                        bne     swap_bp      ; no, do swap with save location
   04bd   de 2c                        ldx     basic_ptr
   04bf   20 0a                        bra     loc_4CB
                        
   04c1   de 2c         swap_bp:       ldx     basic_ptr    ; get basic pointer
   04c3   96 2e                        ldaa    basicptr_save ; move saved pointer to basic ptr
   04c5   97 2c                        staa    basic_ptr
   04c7   96 2f                        ldaa    basicptr_save+1
   04c9   97 2d                        staa    basic_ptr+1
                        
   04cb   df 2e         loc_4CB:       stx     basicptr_save ; store old basic pointer into save
   04cd   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction gosub
                        ;------------------------------------------------------------------------------
   04ce   30            IL_GS:         tsx
   04cf   6c 01                        inc     1,x          ; adjust return address to il_rs_target
   04d1   6c 01                        inc     1,x
   04d3   de 28                        ldx     basic_lineno ; get line number of GOSUB
   04d5   df bc                        stx     IL_temp      ; store it in temp
                        			                        ; an fall thru to payload saver which
                                                            ; injects temp into return stack
                        
                        ;------------------------------------------------------------------------------
                        ; insert IL_temp into return stack
                        ;
                        ; stack holds (low to high addresses)
                        ; SP->
                        ;   return address of exec_il_opcode
                        ;   other data
                        ;
                        ; afterwards
                        ; SP ->
                        ;   return address of exec_il_opcode
                        ;   payload
                        ;   other data
                        ;------------------------------------------------------------------------------
   04d7   34            push_payload:  des                  ; reserve 2 bytes on processor stack
   04d8   34                           des
   04d9   30                           tsx                  ; get address in X
   04da   a6 02                        ldaa    2,x          ; duplicate return address
   04dc   a7 00                        staa    0,x
   04de   a6 03                        ldaa    3,x
   04e0   a7 01                        staa    1,x
   04e2   96 bc                        ldaa    IL_temp      ; insert return address for JS instruction in stack
   04e4   a7 02                        staa    2,x
   04e6   96 bd                        ldaa    IL_temp+1
   04e8   a7 03                        staa    3,x
   04ea   ce 00 24                     ldx     #end_prgm    ; address of end of program
   04ed   9f bc                        sts     IL_temp      ; save current stack in temporary
   04ef   a6 01                        ldaa    1,x          ; check that stack does not run into program code
   04f1   90 bd                        suba    IL_temp+1
   04f3   a6 00                        ldaa    0,x
   04f5   92 bc                        sbca    IL_temp
   04f7   25 20                        bcs     locret_519   ; is still space available?
                                                            ; yes, exit
   04f9   7e 02 5c      j2_error:      jmp    error         ; no error
                        
                        ;------------------------------------------------------------------------------
                        ; return payload in X
                        ;
                        ; stack:
                        ; X
                        ; 0  returnaddr    caller of get_payload
                        ; 1  returnaddr    caller of get_payload
                        ; 2  returnaddr    caller of exec_il_opcode
                        ; 3  returnaddr    caller of exec_il_opcode
                        ; 4  payload
                        ; 5  payload
                        ;------------------------------------------------------------------------------
   04fc   30            get_payload:   tsx                  ; copy return stack addr to X
   04fd   08                           inx                  ; pointing to return address
   04fe   08                           inx                  ; skip over return address and 2 more bytes
                                                            ; point to index 3
   04ff   08                           inx
   0500   9c 22                        cpx     end_ram      ; stack underflow?
   0502   27 f5                        beq     j2_error     ; yes, error
   0504   ee 01                        ldx     1,x          ; get payload into X
   0506   df bc                        stx     IL_temp      ; save it
   0508   30                           tsx                  ; point to return address
   0509   37                           pshb                 ; save B
   050a   c6 04                        ldab    #4           ; move 4 bytes above
                        
   050c   a6 03         gp_loop:       ldaa    3,x
   050e   a7 05                        staa    5,x
   0510   09                           dex
   0511   5a                           decb
   0512   26 f8                        bne     gp_loop      ; loop until done
   0514   33                           pulb                 ; restore B
   0515   31                           ins                  ; drop 1 word (duplicate return address)
   0516   31                           ins
   0517   de bc                        ldx     IL_temp      ; get payload
                        
   0519   39            locret_519:    rts                  ; done
                        
                        ;------------------------------------------------------------------------------
                        ; find BASIC line whose lineno is on stack
                        ; discard from stack
                        ; return found line in basic_ptr
                        ; Z=1 if line is matched exactly
                        ;------------------------------------------------------------------------------
   051a   bd 01 a6      find_line:     jsr     IL_SP        ; pop word into A:B
   051d   d7 bd                        stab    IL_temp+1    ; save in temporary
   051f   97 bc                        staa    IL_temp
   0521   9a bd                        oraa    IL_temp+1    ; check if zero (invalid)
   0523   27 d4                        beq     j2_error     ; if so, error
                        
                                       ; find BASIC line whose lineno is in IL_temp
   0525   de 20         find_line1:    ldx     start_prgm   ; set BASIC pointer to start
   0527   df 2c                        stx     basic_ptr
                        
   0529   bd 04 71      test_line:     jsr     save_lineno  ; save current lineno
                                                            ; note: X = lineno
   052c   27 11                        beq     find_exit    ; if zero, skip to end
   052e   d6 29                        ldab    basic_lineno+1 ; compare line number with current line
   0530   96 28                        ldaa    basic_lineno
   0532   d0 bd                        subb    IL_temp+1
   0534   92 bc                        sbca    IL_temp
   0536   24 07                        bcc     find_exit    ; if above, exit
                        
   0538   bd 03 20      find_eoln:     jsr     fetch_basicchar ; get next char
   053b   26 fb                        bne     find_eoln    ; not CR? loop
   053d   20 ea                        bra     test_line    ; check next line
                        
   053f   9c bc         find_exit:     cpx     IL_temp      ; compare current linenumber with searched one
   0541   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; emit number in A:B
                        ;------------------------------------------------------------------------------
   0542   bd 01 8d      emit_number:   jsr     expr_push_word ; push number on stack
                        
   0545   de c2         IL_PN:         ldx     expr_stack_x ; get address of stack top
   0547   6d 00                        tst     0,x          ; is number negative?
   0549   2a 07                        bpl     loc_552      ; no, skip
   054b   bd 03 c2                     jsr     IL_NE        ; negate top of stack
   054e   86 2d                        ldaa    #'-'         ; emit negative sign
   0550   8d 46                        bsr     emit_char
                        
   0552   4f            loc_552:       clra                 ; push 0 (end of digits)
   0553   36                           psha
   0554   c6 0f                        ldab    #$F
   0556   86 1a                        ldaa    #$1A
   0558   36                           psha                 ; counter for 10's (0x1A)
   0559   37                           pshb                 ; counter for 100's (0x0F)
   055a   36                           psha                 ; counter for 1000's, (0x1A)
   055b   37                           pshb                 ; counter for 10000's (0x0f)
   055c   bd 01 a6                     jsr     IL_SP        ; pop TOS into A:B
   055f   30                           tsx                  ; point to the constants 0xF, 0x1A....
                        
   0560   6c 00         loop_10000s:   inc     0,x          ; increment counter for 10000's
   0562   c0 10                        subb    #$10         ; subtract 10000 (0x2710) until negative
   0564   82 27                        sbca    #$27
   0566   24 f8                        bcc     loop_10000s  ; counter for 10000's will become 0x10...0x14
                        
   0568   6a 01         loop_1000s:    dec     1,x          ; is now negative value, subtract until positive again
   056a   cb e8                        addb    #$E8         ; add 1000 (0x3e8) until positive again 
   056c   89 03                        adca    #3           ; decrement counter for 1000's
   056e   24 f8                        bcc     loop_1000s   ; counter for 1000's will become 0x19...0x10
                        
   0570   6c 02         loop_100s:     inc     2,x          ; is positive value now
   0572   c0 64                        subb    #$64         ; subtract 100 (0x54) until negative
   0574   82 00                        sbca    #0
   0576   24 f8                        bcc     loop_100s    ; counter for 100's becomes 0x10...0x19
                        
   0578   6a 03         loop_10s:      dec     3,x          ; is now negative
   057a   cb 0a                        addb    #$A          ; add 10 until positive again
   057c   24 fa                        bcc    loop_10s      ; counter for 10's become 0x10..0x19
                                                            ; B contains remianing 1's digits
   057e   7f 00 be                     clr     lead_zero    ; clear flag to suppress leading zeroes
                        
   0581   32            emit_digits:   pula                 ; restore counter 10000
   0582   4d                           tsta                 ; was zero?
   0583   27 04                        beq     last_digit   ; yes, last digit to emit, this one is in B
   0585   8d 03                        bsr     emit_digit   ; emit digit in A, suppress leading zeroes
   0587   20 f8                        bra     emit_digits  ; guarantee last digit is printed.
                        
   0589   17            last_digit:    tba                  ; last digit is in B
                        
   058a   81 10         emit_digit:    cmpa    #$10         ; check if '0' (note range is 0x10..19 if not last digit)
   058c   26 05                        bne     emit_digit1  ; no, must emit
                                                            ; note for last digit, any value will be emitted,
                                                            ; because it can't be 0x10 (is 0...9)
   058e   7d 00 be                     tst     lead_zero    ; already emitted a digit?
   0591   27 17                        beq     locret_5AA   ; no, exit (leading zero)
                        
   0593   7c 00 be      emit_digit1:   inc     lead_zero    ; notify digit print
   0596   8a 30                        oraa    #'0'         ; make it a real ASCII '0'...'9'
                                                            ; and print it, by fallthru to emit_char
                        
                        ;------------------------------------------------------------------------------
                        ; emit a character in A
                        ;------------------------------------------------------------------------------
   0598   7c 00 bf      emit_char:     inc     column_cnt   ; advance to column 1
   059b   2b 0a                        bmi     loc_5A7      ; if at column 128, stop emit
   059d   df ba                        stx     X_save       ; save X
   059f   37                           pshb                 ; save B
   05a0   bd 01 09                     jsr     OUT_V        ; emit character
   05a3   33                           pulb                 ; restore B
   05a4   de ba                        ldx     X_save       ; restore X
   05a6   39                           rts                  ; done
                        
   05a7   7a 00 bf      loc_5A7:       dec     column_cnt   ; if column = 0x80, don't advance further
                        
   05aa   39            locret_5AA:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction print string
                        ;------------------------------------------------------------------------------
   05ab   8d eb         pc_loop:       bsr     emit_char    ; emit a character and continue 
                                                            ; with PC instruction
                        
   05ad   bd 01 f5      IL_PC:         jsr     fetch_il_op  ; get next byte of instruction
   05b0   2a f9                        bpl     pc_loop      ; if positive, skip
   05b2   20 e4                        bra     emit_char    ; was last char, emit it and terminate
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction PQ
                        ;------------------------------------------------------------------------------
   05b4   81 22         loop_pq:       cmpa    #'"'         ; is character string terminator?
   05b6   27 f2                        beq     locret_5AA   ; yes, exit
   05b8   8d de                        bsr     emit_char    ; otherwise emit char
                                                            ; and redo PQ instruction
                        
   05ba   bd 03 20      IL_PQ:         jsr     fetch_basicchar ; get next char from BASIC text
   05bd   26 f5                        bne     loop_pq      ; if not CR, loop
   05bf   7e 02 5c                     jmp     error        ; error - unterminated string
                        
                        ;------------------------------------------------------------------------------
                        ;  IL instruction print tab
                        ;------------------------------------------------------------------------------
   05c2   d6 bf         IL_PT:         ldab    column_cnt   ; column counter
   05c4   2b e4                        bmi     locret_5AA   ; if overflow, exit
   05c6   ca f8                        orab    #$F8         ; make 7...0
   05c8   50                           negb
   05c9   20 03                        bra     pt_loop      ; jump to space printer
                        
   05cb   bd 01 a6      pt_print_spc:  jsr     IL_SP        ; drop A:B off stack
                        
   05ce   5a            pt_loop:       decb                 ; decrement low byte
   05cf   2d d9                        blt     locret_5AA   ; < 0, exit
   05d1   86 20                        ldaa    #' '         ; emit a space
   05d3   8d c3                        bsr     emit_char
   05d5   20 f7                        bra     pt_loop      ; loop
                        
                        ;------------------------------------------------------------------------------
                        ; IL Instruction List BASIC source
                        ;------------------------------------------------------------------------------
   05d7   de 2c         IL_LS:         ldx     basic_ptr    ; save current BASIC pointer
   05d9   df b8                        stx     BP_save
   05db   de 20                        ldx     start_prgm   ; default start: begin of program
   05dd   df 2c                        stx     basic_ptr
   05df   de 24                        ldx     end_prgm     ; default end: load X with end of program
   05e1   8d 2c                        bsr     ls_getlineno ; if argument to list given, make this new end
                                                            ; note "LIST start,end", so the first result
                                                            ; popped off stack is the end
   05e3   27 02                        beq     ls_nostart   ; no more argument on stack
   05e5   8d 28                        bsr     ls_getlineno ; save first position in LS_begin
                                                            ; get another argument into basic_ptr, if any
                        
   05e7   96 2c         ls_nostart:    ldaa    basic_ptr    ; compare start and end of listing
   05e9   d6 2d                        ldab    basic_ptr+1
   05eb   d0 b7                        subb    LS_end+1
   05ed   92 b6                        sbca    LS_end
   05ef   24 32                        bcc     ls_exit      ; start > end? yes, exit: nothing (more) to list
   05f1   bd 04 71                     jsr     save_lineno  ; save lineno of current line
   05f4   27 2d                        beq     ls_exit      ; is end of program (line 0)? yes, exit
   05f6   96 28                        ldaa    basic_lineno ; get current line number
   05f8   d6 29                        ldab    basic_lineno+1
   05fa   bd 05 42                     jsr     emit_number  ; print line number
   05fd   86 20                        ldaa    #' '         ; print a space
                        
   05ff   8d 4c         ls_loop:       bsr     j_emitchar
   0601   bd 01 0c                     jsr     BV           ; check for break
   0604   25 1d                        bcs     ls_exit      ; if break, exit
   0606   bd 03 20                     jsr     fetch_basicchar ; get next char from line
   0609   26 f4                        bne     ls_loop      ; if not CR, loop output
   060b   8d 1b                        bsr     IL_NL        ; emit a CRLF
   060d   20 d8                        bra     ls_nostart   ; loop with next line
                        
                        ;------------------------------------------------------------------------------
                        ; called with an address into BASIC code
                        ; return Z=1 if no argument
                        ;------------------------------------------------------------------------------
   060f   08            ls_getlineno:  inx                  ; increment X
   0610   df b6                        stx    LS_end        ; store as default end of listing
   0612   de c2                        ldx    expr_stack_x  ; get expr_stack ptr
   0614   8c 00 80                     cpx    #$80          ; is stack empty?
   0617   27 09                        beq    locret_622    ; yes, no arg given...done
   0619   bd 05 1a                     jsr    find_line     ; find the line (after the lineno) that was given on
                                                            ; stack (start line number)
                                                            ; result in X=basic_ptr
                        
   061c   de 2c         ls_to_linestart: ldx    basic_ptr   ; point back to lineno that was found
   061e   09                           dex
   061f   09                           dex
   0620   df 2c                        stx    basic_ptr     
                        
   0622   39            locret_622:    rts
                        
   0623   de b8         ls_exit:       ldx    BP_save       ; restore old BASIC pointer
   0625   df 2c                        stx    basic_ptr
   0627   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: emit new line
                        ;------------------------------------------------------------------------------
   0628   96 bf         IL_NL:         ldaa    column_cnt   ; if column > 127, suppress output
   062a   2b f6                        bmi     locret_622
                        
                        ;------------------------------------------------------------------------------
                        ; do a CRLF
                        ;------------------------------------------------------------------------------
   062c   86 0d         crlf:          ldaa    #$D          ; emit carriage return character
   062e   8d 1a                        bsr     emit_char_at_0
   0630   f6 01 11                     ldab    PCC          ; get padding mode
   0633   58                           aslb                 ; shift out bit 7
   0634   27 09                        beq     loc_63E      ; if no padding bytes, skip
                        
   0636   37            loc_636:       pshb                 ; save padding count
   0637   8d 0a                        bsr     emit_nul_padding ; emit padding
   0639   33                           pulb                 ; restore count
   063a   5a                           decb                 ; decrement twice (because above 
   063b   58            			   aslb                 ; multiplied *2)
   063c   5a                           decb
   063d   26 f7                        bne     loc_636      ; loop until done
                        
   063f   86 0a         loc_63E:       ldaa    #$A          ; emit line feed character
   0641   8d 0a                        bsr     j_emitchar   ; emit character (with increment column count)
                        
                                                            ; depending on PCC bit 7 emit 
                        									; either NUL or DEL (0xff) byte
   0643   4f            emit_nul_padding: clra              ; padding byte
   0644   7d 01 11                     tst     PCC          ; check if bit 7 of PCC:
                                                            ; =0, emit NUL bytes
                                                            ; =1, emit 0xFF bytes
   0647   2a 01                        bpl     emit_char_at_0 ; emit a NUL byte
   0649   43                           coma
                        
                                       ; emit a char in A and clear column count/XOFF mode
   064a   7f 00 bf      emit_char_at_0: clr    column_cnt   ; reset column to 0
                        
   064d   7e 05 98      j_emitchar:    jmp     emit_char
                        
   0650   b6 01 12      do_xon:        ldaa    TMC          ; get XOFF flag
   0653   20 01                        bra     loc_655
                        
   0655   4f            do_xoff:       clra
                        
   0656   97 bf         loc_655:       staa    column_cnt   ; save column count
   0658   20 0a                        bra     gl_loop
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: get input line
                        ; uses expr_stack as buffer
                        ;------------------------------------------------------------------------------
   065a   ce 00 30      IL_GL:         ldx     #expr_stack  ; store floor of expr_stack as BASIC pointer
   065d   df 2c                        stx     basic_ptr
   065f   df bc                        stx     IL_temp      ; save pointer to char input into buffer
   0661   bd 01 8d                     jsr     expr_push_word ; save A:B for later (may be variable address, or alike)
                        
   0664   98 80         gl_loop:       eora    rnd_seed     ; use random A to create some entropy
   0666   97 80                        staa    rnd_seed
   0668   bd 01 06                     jsr     IN_V         ; get a char from input device
   066b   84 7f                        anda    #$7F         ; make 7bit ASCII
   066d   27 f5                        beq     gl_loop      ; if NUL, ignore
   066f   81 7f                        cmpa    #$7F         ; if 0xFF/0x7F, ignore
   0671   27 f1                        beq     gl_loop
   0673   81 0a                        cmpa    #$A          ; if LF, done
   0675   27 d9                        beq     do_xon
   0677   81 13                        cmpa    #$13         ; if DC3 (XOFF) handle XOFF
   0679   27 da                        beq     do_xoff
   067b   de bc                        ldx     IL_temp      ; get buffer pointer
   067d   b1 01 10                     cmpa    LSC          ; line cancel?
   0680   27 0a                        beq     gl_ctrlx
   0682   b1 01 0f                     cmpa    BSC          ; is it "_" ? (back character)
   0685   26 0c                        bne     gl_chkend    ; no, skip
   0687   8c 00 30                     cpx     #expr_stack  ; at start of buffer?
   068a   26 15                        bne     gl_dobackspace ; no, do a backspace
                        
   068c   de 2c         gl_ctrlx:      ldx     basic_ptr    ; reset pointer to input char
   068e   86 0d                        ldaa    #$D          ; load CR
   0690   7f 00 bf                     clr     column_cnt   ; do XON
                        
   0693   9c c2         gl_chkend:     cpx     expr_stack_x ; is end of buffer reached?
   0695   26 06                        bne     gl_savechar  ; no, skip
   0697   86 07                        ldaa    #7           ; emit BEL character (line overflow)
   0699   8d b2                        bsr     j_emitchar
   069b   20 c7                        bra     gl_loop      ; loop
                        
   069d   a7 00         gl_savechar:   staa    0,x          ; save char in buffer
   069f   08                           inx                  ; advance
   06a0   08                           inx
                        
   06a1   09            gl_dobackspace:  dex
   06a2   df bc                        stx     IL_temp      ; !!! error in dump, was 0F
                                                            ; save new ptr to input
   06a4   81 0d                        cmpa    #$D          ; was char CR?
   06a6   26 bc                        bne     gl_loop      ; no, get another char
   06a8   bd 06 28                     jsr     IL_NL        ; end of input reached
   06ab   96 bd                        ldaa    IL_temp+1    ; get buffer line
   06ad   97 c1                        staa    expr_stack_low ; save as new expr_stack bottom
                                                            ; (should not overwrite buffer)
   06af   7e 01 a6                     jmp     IL_SP        ; pop old value off stack
                        
                        ;------------------------------------------------------------------------------
                        ; IL instruction: insert BASIC line
                        ;------------------------------------------------------------------------------
   06b2   bd 04 c1      IL_IL:         jsr     swap_bp      ; basicptr_save = 0x80 (input buffer)
                                                            ; basic_ptr = invalid
   06b5   bd 05 1a                     jsr     find_line    ; search for line with lineno from stack
                                                            ; if found: address of BASIC text in basic_ptr
                                                            ; if not: address of next line or end of program
   06b8   07                           tpa                  ; save status, whether line was found
   06b9   bd 06 1c                     jsr     ls_to_linestart ; adjust line back to lineno
   06bc   df b8                        stx     BP_save      ; save this in BP_save as well.
                                                            ; basic_ptr==BP_save is position where to enter
                                                            ; new line (if same lineno, overwrite)
   06be   de bc                        ldx     IL_temp      ; save lineno to be handled in LS_end
   06c0   df b6                        stx     LS_end
   06c2   5f                           clrb                 ; preload length of stored line with 0
                                                            ; for line not found (must grow)
   06c3   06                           tap                  ; restore status of find_line
   06c4   26 0b                        bne     il_linenotfound ; skip if lineno not matched
                                                            ; hey, this line already exists!
   06c6   bd 04 71                     jsr     save_lineno  ; save lineno where we are currently in basic_lineno
   06c9   c6 fe                        ldab    #$FE         ; advance to end of line,
                                                            ; B is negative length of line
                        
   06cb   5a            il_findeoln:   decb
   06cc   bd 03 20                     jsr     fetch_basicchar
   06cf   26 fa                        bne     il_findeoln  ; loop until end of line
                                                            ; B now contains negative sizeof(stored line)
                        
   06d1   ce 00 00      il_linenotfound: ldx   #0           ; B is 0, if line does not yet exist
   06d4   df 28                        stx     basic_lineno ; clear lineno
   06d6   bd 04 c1                     jsr     swap_bp      ; basic_ptr = 0x80 (input buffer)
                                                            ; basicptr_save = at end of position to insert
                                                            ; (i.e. either before following line, or at end of
                                                            ; line to be grown/shrunk)
   06d9   86 0d                        ldaa    #$D          ; calculate sizeof(input buffer)
                                                            ; load EOLN char
   06db   de 2c                        ldx    basic_ptr     ; start at input buffer (after line number)
   06dd   a1 00                        cmpa    0,x          ; is it eoln?
   06df   27 0c                        beq     loc_6EC      ; yes, skip - this is an empty line: must delete
   06e1   cb 03                        addb    #3           ; no, reserve 3 bytes for lineno and CR
                        
   06e3   5c            loc_6E2:       incb                 ; increment B for every byte in current line <> eoln
   06e4   08                           inx
   06e5   a1 00                        cmpa    0,x          ; advance and check for EOLN
   06e7   26 fa                        bne     loc_6E2      ; loop until eoln found
                                                            ;
                                                            ; all in all, B contains the difference of line lengths:
                                                            ;  -sizeof(stored line)+sizeof(input buffer)
                                                            ; if negative: stored is longer  than new -> shrink program
                                                            ; if zero: stored is same size
                                                            ; if positive: stored is shorter than new -> grow program
   06e9   de b6                        ldx     LS_end       ; restore current lineno
                                                            ; is non-null: there is a line to add
   06eb   df 28                        stx     basic_lineno
                        
   06ed   de b8         loc_6EC:       ldx     BP_save      ; IL_temp = start of area to insert line
   06ef   df bc                        stx     IL_temp
   06f1   5d                           tstb                 ; check number of bytes
                                                            ; negative: shrink program
                                                            ; zero: nothing to move
                                                            ; positive: grow program
   06f2   27 55                        beq     il_samesize  ; same size, just copy
   06f4   2a 23                        bpl     il_growline  ; stored line is longer -> shrink
   06f6   96 2f                        ldaa    basicptr_save+1 ; BP_save = end_of_insert - bytes to shrink
   06f8   1b                           aba
   06f9   97 b9                        staa    BP_save+1
   06fb   96 2e                        ldaa    basicptr_save
   06fd   89 ff                        adca    #$FF
   06ff   97 b8                        staa    BP_save      ; BP_save < basicptr_save < end_pgrm < top_of_stack (hopefully)
                        
   0701   de 2e         il_shrink:     ldx     basicptr_save ; copy from end of insert addr to BP_save addr
   0703   e6 00                        ldab    0,x
   0705   9c 24                        cpx     end_prgm     ; until end of program
   0707   27 3c                        beq     loc_744
   0709   9c 26                        cpx     top_of_stack ; or until top_of_stack
   070b   27 38                        beq     loc_744      ; leave, when done
   070d   08                           inx                  ; advance
   070e   df 2e                        stx     basicptr_save
   0710   de b8                        ldx     BP_save
   0712   e7 00                        stab    0,x          ; save the byte
   0714   08                           inx
   0715   df b8                        stx     BP_save
   0717   20 e8                        bra     il_shrink    ; loop until done
                        
   0719   db 25         il_growline:   addb    end_prgm+1   ; make space after end of program for B bytes
   071b   d7 2f                        stab    basicptr_save+1
   071d   86 00                        ldaa    #0
   071f   99 24                        adca    end_prgm
   0721   97 2e                        staa    basicptr_save ; basicptr_save = new end of program
   0723   d0 27                        subb    top_of_stack+1
   0725   92 26                        sbca    top_of_stack ; verify it's below top_of_RAM
   0727   25 06                        bcs     il_dogrow    ; ok, continue
   0729   7a 00 2b                     dec     il_pc+1      ; point back to IL instruction
   072c   7e 02 5c                     jmp     error        ; overflow error
                        
   072f   de 2e         il_dogrow:     ldx     basicptr_save ; BP_save is new end of program
   0731   df b8                        stx     BP_save
                        
   0733   de 24         il_grow:       ldx     end_prgm     ; get byte from old end of program
   0735   a6 00                        ldaa    0,x
   0737   09                           dex                  ; advance back
   0738   df 24                        stx     end_prgm
   073a   de 2e                        ldx     basicptr_save ; store byte at new end of program
   073c   a7 00                        staa    0,x
   073e   09                           dex
   073f   df 2e                        stx     basicptr_save
   0741   9c bc                        cpx     IL_temp
   0743   26 ee                        bne     il_grow      ; loop until done
                        
   0745   de b8         loc_744:       ldx     BP_save      ; adjust new end of program
   0747   df 24                        stx     end_prgm
                        
   0749   de 28         il_samesize:   ldx     basic_lineno ; now there is space at position for the new line
                                                            ; check lineno:  is 0 if delete
   074b   27 19                        beq     il_done      ; nothing to copy (gap is already closed)
   074d   de bc                        ldx     IL_temp      ; start of area to insert into (the gap)
   074f   96 28                        ldaa    basic_lineno ; store the line number into this area
   0751   d6 29                        ldab    basic_lineno+1
   0753   a7 00                        staa    0,x
   0755   08                           inx
   0756   e7 00                        stab    0,x
                        
   0758   08            il_moveline:   inx
   0759   df bc                        stx     IL_temp      ; position of gap
   075b   bd 03 20                     jsr     fetch_basicchar ; get char from input buffer
   075e   de bc                        ldx     IL_temp      ; put it into gap
   0760   a7 00                        staa    0,x
   0762   81 0d                        cmpa    #$D          ; until EOLN
   0764   26 f2                        bne     il_moveline
                        
   0766   9e 26         il_done:       lds     top_of_stack ; finished with IL
                                                            ; reload stack pointer
   0768   7e 02 2a                     jmp     restart_il_nocr ; and re-enter BASIC loop
                        
                        ;------------------------------------------------------------------------------
                        ; Break routine for Motorola MINIBUG
                        ;------------------------------------------------------------------------------
   076b   b6 fc 18      minibug_chkbreak: ldaa    $FC18        ; ACIA control status
   076e   47                           asra                 ; check bit0: receive buffer full
   076f   24 06                        bcc     locret_776   ; no, exit, carry clear
   0771   b6 fc 19                     ldaa    $FC19        ; load ACIA data
   0774   26 01                        bne     locret_776   ; if not NUL, return carry set
   0776   0c                           clc                  ; was NUL, ignore, retun carry clear
                        
   0777   39            locret_776:    rts
                        
                        ;------------------------------------------------------------------------------
                        ; Input/Echo routine for Motorola MINIBUG
                        ;------------------------------------------------------------------------------
   0778   b6 fc 18      minibug_inoutput: ldaa $FC18        ; get ACIA status
   077b   47                           asra                 ; check bit: receiver buffer empty?
   077c   24 fa                        bcc     minibug_inoutput ; yes, wait for char
   077e   b6 fc 19                     ldaa    $FC19        ; get ACIA data
   0781   36                           psha                 ; save it for later
                        
   0782   b6 fc 18      wait_tdre:     ldaa    $FC18        ; get ACIA status
   0785   84 02                        anda    #2           ; check bit1: transmit buf empty?
   0787   27 f9                        beq     wait_tdre    ; no, wait until transmitted
   0789   32                           pula                 ; restore char
   078a   b7 fc 19                     staa    $FC19        ; echo data just entered
   078d   39                           rts
                        
                        ;------------------------------------------------------------------------------
                        ; test break routine for MIKBUG
                        ;------------------------------------------------------------------------------
   078e   b6 80 04      mikbug_chkbreak: ldaa    $8004      ; check bitbang input of PIA
   0791   0c                           clc
   0792   2b 0d                        bmi     locret_7A0   ; if 1, exit: no input
                        
   0794   b6 80 04      loc_793:       ldaa    $8004        ; is zero, wait until 1
   0797   2a fb                        bpl     loc_793
   0799   8d 00                        bsr     *+2          ; emit byte 0xFF twice
   079b   86 ff                        ldaa    #$FF         ; emit 0xFF
   079d   bd 01 09                     jsr     OUT_V
   07a0   0d                           sec
                        
   07a1   39            locret_7A0:    rts
                        
                        ;******************************************************************************
                        ; The IL interpreter commented
                        ;******************************************************************************
   07a2   24 3a 91      start_of_il:   fcb $24,':',$11+$80  ; PL    : print literal ":",XON
   07a5   27                           fcb $27              ; GL    : get input line
   07a6   10                           fcb $10              ; SB    : save BASIC pointer
   07a7   e1                           fcb $E1              ; BE  01: if not eoln, branch to il_test_insert
   07a8   59                           fcb $59              ; BR  19: branch to start_of_il
   07a9   c5            il_test_insert: fcb $C5             ; BN  05: if not number, branch to il_test_let
   07aa   2a                           fcb $2A              ; IL    : insert BASIC line
   07ab   56                           fcb $56              ; BR  16: branch to start_of_il
   07ac   10            il_run:        fcb $10              ; SB    : save BASIC pointer
   07ad   11                           fcb $11              ; RB    : restore BASIC pointer
   07ae   2c                           fcb $2C              ; XC    : execute
   07af   8b 4c 45 d4   il_test_let:   fcb $8B,'L','E',$D4  ; BC  0B: if not "LET", branch to il_test_go
   07b3   a0                           fcb $A0              ; BV  00: if not variable, error
   07b4   80 bd                        fcb $80,'='+$80      ; BC  00: if not "=", error
   07b6   30 bc         il_let:        fcb $30,$BC          ; JS 0BC: call il_expr
   07b8   e0                           fcb $E0              ; BE  00: if not eoln, error
   07b9   13                           fcb $13              ; SV    : store variable
   07ba   1d                           fcb $1D              ; NX    : next BASIC statement
   07bb   94 47 cf      il_test_go:    fcb $94,'G','O'+$80  ; BC  14: if not "GO", branch to il_test_10
   07be   88 54 cf                     fcb $88,'T','O'+$80  ; BC  08: if not "TO", branch to il_test_sub
   07c1   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07c3   e0                           fcb $E0              ; BE  00: if not eoln, error
   07c4   10                           fcb $10              ; SB    : save BASIC pointer
   07c5   11                           fcb $11              ; RB    : restore BASIC pointer
   07c6   16                           fcb $16              ; GO    : GOTO
   07c7   80 53 55 c2   il_test_sub:   fcb $80,'S','U','B'+$80
                                                            ; BC  00: if not "SUB", error
   07cb   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07cd   e0                           fcb $E0              ; BE  00: if not eoln, error
   07ce   14                           fcb $14              ; GS    : GOSUB save
   07cf   16                           fcb $16              ; GO    : GOTO
   07d0   90 50 d2      il_test_pr:    fcb $90,'P','R'+$80  ; BC  10: if not "PR", branch to il_jump1
   07d3   83 49 4e d4                  fcb $83,'I','N','T'+$80 
                                                            ; BC  03: if not "INT", branch to il_print
   07d7   e5            il_print:      fcb $E5              ; BE  05: if not eoln, branch to il_pr_test_dq
   07d8   71                           fcb $71              ; BR  31: branch to il_pr_must_eoln
   07d9   88 bb         il_pr_test_semi: fcb $88,';'+$80    ; BC  08: if not ";", branch to il_pr_test_com
   07db   e1            il_pr_eoln:    fcb $E1              ; BE  01: if not eoln, branch to il_pr_test_dq
   07dc   1d                           fcb $1D              ; NX    : next BASIC statement
   07dd   8f a2         il_pr_test_dq: fcb $8F,'"'+$80      ; BC  0F: if not dblquote, branch to il_pr_expr
   07df   21                           fcb $21              ; PQ    : print    BASIC string
   07e0   58                           fcb $58              ; BR  18: branch to il_test_semi
   07e1   6f            il_jump1:      fcb $6F              ; BR  2F: branch to il_test_if
   07e2   83 ac         il_pr_test_com: fcb $83,','+$80     ; BC  03: if not ",", branch to il_test_colon
   07e4   22                           fcb $22              ; PT    : print TAB
   07e5   55                           fcb $55              ; BR  15: branch to il_pr_eoln
   07e6   83 ba         il_test_colon: fcb $83,':'+$80      ; BC  03: if not ":", branch to il_pr_must_eoln
   07e8   24 93                        fcb $24,$13+$80      ; PR    : print literal XOFF
   07ea   e0            il_pr_must_eoln: fcb $E0            ; BE  00: if not eoln, error
   07eb   23                           fcb $23              ; NL    : new line
   07ec   1d                           fcb $1D              ; NX    : next statement
   07ed   30 bc         il_pr_expr:    fcb $30,$BC          ; JS 0BC: call il_expr
   07ef   20                           fcb $20              ; PN    : print number
   07f0   48                           fcb $48              ; BR  08: branch to il_pr_test_semi
   07f1   91 49 c6                     fcb $91,'I','F'+$80  ; BC  11: if not "IF", branch to il_test_input
   07f4   30 bc         il_test_if:    fcb $30,$BC          ; JS 0BC: call il_expr
   07f6   31 34                        fcb $31,$34          ; JS 134: call il_cmpop
   07f8   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   07fa   84 54 48 45                  fcb $84,'T','H','E','N'+$80
   07fe   ce            
                                                            ; BC  04: if not "THEN", branch to il_test_input
   07ff   1c                           fcb $1C              ; CP    : compare
   0800   1d                           fcb $1D              ; NX    : next BASIC statement
   0801   38 0d                        fcb $38,$D           ; J  00D: jump il_test_let
   0803   9a 49 4e 50   il_test_input: fcb $9A,'I','N','P','U','T'+$80
   0807   55 d4         
                                                            ; BC  1A: if not "INPUT", branch to il_test_return
   0809   a0            il_in_more:    fcb $A0              ; BV  00: if not variable, error
   080a   10                           fcb $10              ; SB    : save BASIC pointer
   080b   e7                           fcb $E7              ; BE  07: if not eoln, branch to il_in_test_com
   080c   24 3f 20 91   il_in_query:   fcb $24,'?',' ',$11+$80
                                                            ; PR    : print literal "? ",XON
   0810   27                           fcb $27              ; GL    : get input line
   0811   e1                           fcb $E1              ; BE  01: if not eoln, branch to il_in_test_com
   0812   59                           fcb $59              ; BR  19: branch to il_in_query
   0813   81 ac         il_in_test_com: fcb $81,','+$80     ; BC  01: if not ",", branch to il_in_get
   0815   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   0817   13                           fcb $13              ; SV    : store variable
   0818   11                           fcb $11              ; RB    : restore BASIC pointer
   0819   82 ac                        fcb $82,','+$80      ; BC  02: if not ",", branch il_in_done
   081b   4d                           fcb $4D              ; BR  0D: branch to il_in_more
   081c   e0                           fcb $E0              ; BE  00: if not eoln, error
   081d   1d                           fcb $1D              ; NX    : next BASIC statement
   081e   89 52 45 54   il_test_return: fcb $89,'R','E','T','U','R','N'+$80
   0822   55 52 ce      
                                                            ; BC  09: if not "RETURN", branch to il_test_end
   0825   e0                           fcb $E0              ; BE  00: if not eoln, error
   0826   15                           fcb $15              ; RS    : restore saved line
   0827   1d                           fcb $1D              ; NX    : next BASIC statement
   0828   85 45 4e c4   il_test_end:   fcb $85,'E','N','D'+$80
                                                            ; BC  05: if not "END", branch to il_test_list
   082c   e0                           fcb $E0              ; BE  00: if not eoln, error
   082d   2d                           fcb $2D              ; WS    : stop
   082e   98 4c 49 53   il_test_list:  fcb $98,'L','I','S','T'+$80
   0832   d4            
                                                            ; BC  18: if not "LIST", branch to il_test_run
   0833   ec                           fcb $EC              ; BE  0C: if not eoln, branch to il_li_line
   0834   24 00 00 00   il_li_newline: fcb $24,0,0,0,0,$0A,0+$80
   0838   00 0a 80      
                                                            ; PR    : print literal NUL,NUL,NUL,NUL,LF,NUL
   083b   1f                           fcb $1F              ; LS    : list the program
   083c   24 93                        fcb $24,$13+$80      ; PR    : print literal XOFF
   083e   23                           fcb $23              ; NL    : newline
   083f   1d                           fcb $1D              ; NX    : next BASIC statement
   0840   30 bc         il_li_line:    fcb $30,$BC          ; JS 0BC: call il_expr
   0842   e1                           fcb $E1              ; if not eoln, branch to il_li2
   0843   50                           fcb $50              ; BR  10: branch to il_li_newline
   0844   80 ac                        fcb $80,','+$80      ; BC  00: if not ",", error
   0846   59                           fcb $59              ; BR  19: branch to il_li_line
   0847   85 52 55 ce   il_test_run:   fcb $85,'R','U','N'+$80
                                                            ; BC  05: if not "RUN", branch to il_test_clear
   084b   38 0a                        fcb $38,$0A          ; J  00A: branch to il_run
   084d   86 43 4c 45   il_test_clear: fcb $86,'C','L','E','A','R'+$80
   0851   41 d2         
                                                            ; BC  06: if not "CLEAR", branch to il_test_rem
   0853   2b                           fcb $2B              ; MT   : mark basic program space empty
   0854   84 52 45 cd   il_test_rem:   fcb $84,'R','E','M'+$80
                                                            ; BC  04: if not "REM, branch to il_assign
   0858   1d                           fcb $1D              ; NX    : next BASIC statement
   0859   a0                           fcb $A0              ; BV  00: if not variable, error
   085a   80 bd         il_assign:     fcb $80,'='+$80      ; BC  00: if not "=", error
   085c   38 14                        fcb $38,$14          ; J  014: branch to il_let
   085e   85 ad         il_expr:       fcb $85,'-'+$80      ; if not "-", branch to il_expr_plus
   0860   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   0862   17                           fcb $17              ; NE    : negate
   0863   64                           fcb $64              ; BR  24: branch to il_expr1
   0864   81 ab         il_expr_plus:  fcb $81,'+'+$80      ; BC  01: if not "+", branch to il_expr0
   0866   30 d3         il_expr0:      fcb $30,$D3          ; JS 0D3: call il_term
   0868   85 ab         il_expr1:      fcb $85,'+'+$80      ; BC  05: if not "+", branch to il_expr2
   086a   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   086c   18                           fcb $18              ; AD    : add
   086d   5a                           fcb $5A              ; BR  1A: branch to il_expr1
   086e   85 ad         il_expr2:      fcb $85,'-'+$80      ; BC  05: if not "-", branch to il_term
   0870   30 d3                        fcb $30,$D3          ; JS 0D3: call il_term
   0872   19                           fcb $19              ; SU    : subtract
   0873   54                           fcb $54              ; BR  14: branch to il_expr1
   0874   2f            il_expr3:      fcb $2F              ; RT    : return
   0875   30 e2         il_term:       fcb $30,$E2          ; JS 0E2: call il_fact
   0877   85 aa         il_term0:      fcb $85,'*'+$80      ; BC 05: if not "*", branch to il_term1
   0879   30 e2                        fcb $30,$E2          ; JS 0E2: call il_factor
   087b   1a                           fcb $1A              ; MP    : multiply
   087c   5a                           fcb $5A              ; BR  1A: branch to il_term0
   087d   85 af         il_term1:      fcb $85,'/'+$80      ; if not "/", branch to il_term2
   087f   30 e2                        fcb $30,$E2          ; JS 0E2: call il_factor
   0881   1b                           fcb $1B              ; DV    : divide
   0882   54                           fcb $54              ; BR  14: branch to il_term0
   0883   2f            il_term2:      fcb $2F              ; RT    : return
   0884   98 52 4e c4   il_factor:     fcb $98,'R','N','D'+$80
                                                            ; BC  18: if not RND, branch to il_factor1
   0888   0a 80 80                     fcb  $A,$80,$80      ; LN    : push literal 0x8080
   088b   12                           fcb $12              ; FV    : fetch variable rnd_seed
   088c   0a 09 29                     fcb  $A,$09,$29      ; LN    : push literal 0x0929
   088f   1a                           fcb $1A              ; MP    : multiply
   0890   0a 1a 85                     fcb  $A,$1A,$85      ; LN    : push literal 0x1A85
   0893   18                           fcb $18              ; AD    : add
   0894   13                           fcb $13              ; SV    : store variable rnd_seed
   0895   09 80                        fcb   9,$80          ; LB    : push literal byte 0x80
   0897   12                           fcb $12              ; FV    : fetch variable rnd_seed
   0898   01                           fcb   1              ; SX  01: stack    exchange
   0899   0b                           fcb  $B              ; DS    : duplicate stack top
   089a   31 30                        fcb $31,$30          ; JS 130: call il_rn_paren
   089c   61                           fcb $61              ; BR  21: branch to il_factor2
   089d   72            il_factor1:    fcb $72              ; BR  32: branch to il_usr
   089e   0b            il_factor2:    fcb  $B              ; DS    : duplicate stack top
   089f   04                           fcb   4              ; SX  04: stack    exchange
   08a0   02                           fcb   2              ; SX  02: stack    exchange
   08a1   03                           fcb   3              ; SX  03: stack    exchange
   08a2   05                           fcb   5              ; SX  05: stack    exchange
   08a3   03                           fcb   3              ; SX  03: stack    exchange
   08a4   1b                           fcb $1B              ; DV    : divide
   08a5   1a                           fcb $1A              ; MP    : multiply
   08a6   19                           fcb $19              ; SU    : subtract
   08a7   0b                           fcb  $B              ; DS    : duplicate stack top
   08a8   09 06                        fcb   9,$06          ; LB    : push literal byte 0x06
   08aa   0a 00 00                     fcb  $A,$00,$00      ; LN    : push literal number 0x0000
   08ad   1c                           fcb $1C              ; CP    : compare
   08ae   17                           fcb $17              ; NE    : negate
   08af   2f                           fcb $2F              ; RT    : return
   08b0   8f 55 53 d2   il_usr:        fcb $8F,'U','S','R'+$80
                                                            ; BC  0F: if not "USR", branch to il_factor3
   08b4   80                           fcb $80              ; BC  00: if not "(", error
   08b5   a8                           fcb $A8              ; if not variable, branch to il_usr1
   08b6   30 bc                        fcb $30,$BC          ; JS 0BC: call il_expr
   08b8   31 2a                        fcb $31,$2A          ; JS 12A: call il_us_test_com
   08ba   31 2a                        fcb $31,$2A          ; JS 12A: call il_us_test_com
   08bc   80 a9                        fcb $80,')'+$80      ; BC  00: if not ")", error
   08be   2e            il_usr1:       fcb $2E              ; US    : machine language call
   08bf   2f                           fcb $2F              ; RT    : return
   08c0   a2            il_factor3:    fcb $A2              ; BV  02: if not variable, branch to il_factor4
   08c1   12                           fcb $12              ; FV    : fetch    variable
   08c2   2f                           fcb $2F              ; RT    : return
   08c3   c1            il_factor4:    fcb $C1              ; BN  01: if not number, branch    to il_lparen
   08c4   2f                           fcb $2F              ; RT    : return
   08c5   80 a8                        fcb $80,'('+$80      ; BC  00: if not "(", error
   08c7   30 bc         il_factor5:    fcb $30,$BC          ; JS 0BC: call il_expr
   08c9   80 a9                        fcb $80,')'+$80      ; BC  00: if not ")", error
   08cb   2f                           fcb $2F              ; RT    : return
   08cc   83 ac         il_us_test_com: fcb $83,','+$80     ; BC  03: if not ",", branch to il_us_dup
   08ce   38 bc                        fcb $38,$BC          ; J  0BC: branch to il_expr
   08d0   0b            il_us_dup:     fcb  $B              ; DS    : duplicate stack top
   08d1   2f                           fcb $2F              ; RT    : return
   08d2   80 a8         il_rn_paren:   fcb $80,'('+$80      ; BC  00: if not "(", error
   08d4   52                           fcb $52              ; BR  12: branch to il_factor5
   08d5   2f                           fcb $2F              ; RT    : return
   08d6   84 bd         il_cmpop:      fcb $84,'='+$80      ; if not "=", branch to il_cmpop1
   08d8   09 02                        fcb   9,$02          ; LB    : push literal byte 0x02
   08da   2f                           fcb $2F              ; RT    ; return
   08db   8e bc         il_cmpop1:     fcb $8E,'<'+$80      ; BR  0E: if not "<", branch to il_cmpop4
   08dd   84 bd                        fcb $84,'='+$80      ; BR  04: if not "=", branch to il_cmpop2
   08df   09 93                        fcb   9,$93          ; LB    : push literal byte 0x93
   08e1   2f                           fcb $2F              ; RT    : return
   08e2   84 be         il_cmpop2:     fcb $84,'>'+$80      ; BR  04: if not ">", branch to il_cmpop3
   08e4   09 05                        fcb   9,$05          ; LB    : push literal byte 0x05
   08e6   2f                           fcb $2F              ; RT    : return
   08e7   09 91         il_cmpop3:     fcb   9,$91          ; LB    : push literal byte 0x91
   08e9   2f                           fcb $2F              ; RT    : return
   08ea   80 be         il_cmpop4:     fcb $80,'>'+$80      ; BR  00: if not ">", error
   08ec   84 bd                        fcb $84,'='+$80      ; BR  04: if not "=", branch to il_cmpop5
   08ee   09 06                        fcb   9,$06          ; LB    : push literal byte 0x06
   08f0   2f                           fcb $2F              ; RT    : return
   08f1   84 bc         il_cmpop5:     fcb $84,'<'+$80      ; BR  04: if not "<", branch to il_cmpop6
   08f3   09 95                        fcb   9,$95          ; LB    : push literal byte 0x95
   08f5   2f                           fcb $2F              ; RT    : return
   08f6   09 04         il_cmpop6:     fcb   9,$04          ; LB    : push literal byte 0x04
   08f8   2f                           fcb $2F              ; RT   :return
   08f9   00                           fcb 0
   08fa   00                           fcb 0
                        
                        ;------------------------------------------------------------------------------
                        ; not called: reference code for break check for MIKBUG/MINIBUG monitors
                        ;------------------------------------------------------------------------------
   08fb   7e 07 6b                     jmp     minibug_chkbreak
   08fe   7e 07 8e                     jmp     mikbug_chkbreak
                        
   0901                 		       end
00b8  BP_save       010f  BSC           010c  BV            0200  COLD_S    
0100  CV            03cf  IL_AD         0298  IL_BBR        02ee  IL_BC     
030b  IL_BE         033b  IL_BN         0312  IL_BV         0423  IL_CP     
0189  IL_DS         036b  IL_DV         029b  IL_FBR        0400  IL_FV     
065a  IL_GL         048e  IL_GO         04ce  IL_GS         06b2  IL_IL     
01d7  IL_LB         01db  IL_LN         05d7  IL_LS         03e5  IL_MP     
0212  IL_MT         03c2  IL_NE         0628  IL_NL         01fc  IL_NO     
0449  IL_NX         05ad  IL_PC         0545  IL_PN         05ba  IL_PQ     
05c2  IL_PT         04b0  IL_RB         0499  IL_RS         04a6  IL_RT     
04ab  IL_SB         01a6  IL_SP         03cd  IL_SU         0410  IL_SV     
01b9  IL_US         047e  IL_XQ         01fe  IL_baseaddr    00bc  IL_temp   
0106  IN_V          0110  LSC           00b6  LS_end        0109  OUT_V     
0111  PCC           0113  SSS           0112  TMC           0225  WARM_S    
0103  WV            00ba  X_save        0028  basic_lineno    002c  basic_ptr 
002e  basicptr_save    02fe  bc_lastchar    02f2  bc_loop       0305  bc_nomatch
00bf  column_cnt    0440  cp_is_eq      043e  cp_is_gt      0442  cp_is_lt  
062c  crlf          02ea  displ_error    0462  do_break      048a  do_runmode
0655  do_xoff       0650  do_xon        0394  dv_loop       03ae  dv_shift  
03ab  dv_smaller    0598  emit_char     064a  emit_char_at_0    058a  emit_digit
0593  emit_digit1    0581  emit_digits    0643  emit_nul_padding    0542  emit_number
0024  end_prgm      0022  end_ram       0293  err_at        025c  error     
028a  error_no_lineno    0246  exec_il_opcode    03e0  expr_check_4bytes    03e2  expr_check_nbytes
01a9  expr_pop_byte    0196  expr_push_a    0194  expr_push_byte    018d  expr_push_word
03d9  expr_save_pop    0030  expr_stack    00c1  expr_stack_low    00c3  expr_stack_top
00c2  expr_stack_x    0320  fetch_basicchar    01f5  fetch_il_op    0205  find_end_ram
0538  find_eoln     053f  find_exit     051a  find_line     0525  find_line1
032a  get_nchar     04fc  get_payload    0693  gl_chkend     068c  gl_ctrlx  
06a1  gl_dobackspace    0664  gl_loop       069d  gl_savechar    0493  go_error  
0456  go_found_line    050c  gp_loop       02a5  handle_30_ff    02cc  handle_40_ff
01e4  handle_il_SX    085a  il_assign     08d6  il_cmpop      08db  il_cmpop1 
08e2  il_cmpop2     08e7  il_cmpop3     08ea  il_cmpop4     08f1  il_cmpop5 
08f6  il_cmpop6     072f  il_dogrow     0766  il_done       085e  il_expr   
0866  il_expr0      0868  il_expr1      086e  il_expr2      0874  il_expr3  
0864  il_expr_plus    0884  il_factor     089d  il_factor1    089e  il_factor2
08c0  il_factor3    08c3  il_factor4    08c7  il_factor5    06cb  il_findeoln
02a0  il_goto       0733  il_grow       0719  il_growline    0809  il_in_more
080c  il_in_query    0813  il_in_test_com    07e1  il_jump1      011b  il_jumptable
07b6  il_let        0840  il_li_line    0834  il_li_newline    06d1  il_linenotfound
023b  il_mainloop    0758  il_moveline    002a  il_pc         00c4  il_pc_save
07db  il_pr_eoln    07ed  il_pr_expr    07ea  il_pr_must_eoln    07e2  il_pr_test_com
07dd  il_pr_test_dq    07d9  il_pr_test_semi    07d7  il_print      08d2  il_rn_paren
0239  il_rs_return    0241  il_rs_target    07ac  il_run        0749  il_samesize
0701  il_shrink     0875  il_term       0877  il_term0      087d  il_term1  
0883  il_term2      084d  il_test_clear    07e6  il_test_colon    0828  il_test_end
07bb  il_test_go    07f4  il_test_if    0803  il_test_input    07a9  il_test_insert
07af  il_test_let    082e  il_test_list    07d0  il_test_pr    0854  il_test_rem
081e  il_test_return    0847  il_test_run    07c7  il_test_sub    08d0  il_us_dup 
08cc  il_us_test_com    08b0  il_usr        08be  il_usr1       0467  j1_error  
04f9  j2_error      0309  j_FBR         0420  j_IL_SP       064d  j_emitchar
01a3  j_error       03dd  j_expr_pop_byte    0589  last_digit    00be  lead_zero 
0389  loc_389       046a  loc_46A       04b3  loc_4B3       04cb  loc_4CB   
0552  loc_552       05a7  loc_5A7       0636  loc_636       063f  loc_63E   
0656  loc_655       06e3  loc_6E2       06ed  loc_6EC       0745  loc_744   
0794  loc_793       033a  locret_33A    03cc  locret_3CC    0461  locret_461
0519  locret_519    05aa  locret_5AA    0622  locret_622    0777  locret_776
07a1  locret_7A0    0560  loop_10000s    0568  loop_1000s    0570  loop_100s 
0578  loop_10s      0344  loop_bn       05b4  loop_pq       0623  ls_exit   
060f  ls_getlineno    05ff  ls_loop       05e7  ls_nostart    061c  ls_to_linestart
078e  mikbug_chkbreak    076b  minibug_chkbreak    0778  minibug_inoutput    03ed  mp_loop   
03f9  mp_notadd     03ca  ne_nocarry    03c4  negate        02e2  not_bbr   
044d  nx_loop       05ab  pc_loop       0114  peek          0118  poke      
01ab  pop_byte      05ce  pt_loop       05cb  pt_print_spc    04d7  push_payload
0227  restart_il    022a  restart_il_nocr    0080  rnd_seed      00c0  run_mode  
0471  save_lineno    07a2  start_of_il    0020  start_prgm    0177  sub_177   
0180  sub_180       04c1  swap_bp       0529  test_line     0026  top_of_stack
01cd  us_copyargs    01c0  us_do         0082  var_tbl       0782  wait_tdre 
